#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <stdbool.h>
#include <stdio.h>

const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
const int ROWS = 5;
const int COLS = 5;
const int CELL_SIZE = 40;
const int INDEX_OFFSET = 20;

SDL_Window* gWindow = NULL;
SDL_Renderer* gRenderer = NULL;

bool **picrossGrid = NULL;

// Prototypes des fonctions
void initializeSDL();
void closeSDL();
void initPicrossGrid();
void freePicrossGrid();
void handleMouseClick(int x, int y);
void render();
void drawGrid();
void drawIndices();


void initializeSDL() {
    SDL_Init(SDL_INIT_VIDEO);
    TTF_Init();
    gWindow = SDL_CreateWindow("Picross", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED);
}

void closeSDL() {
    SDL_DestroyRenderer(gRenderer);
    SDL_DestroyWindow(gWindow);
    TTF_Quit();
    SDL_Quit();
}

void initPicrossGrid() {
    picrossGrid = (bool**)malloc(ROWS * sizeof(bool*));
    for (int i = 0; i < ROWS; i++) {
        picrossGrid[i] = (bool*)malloc(COLS * sizeof(bool));
        for (int j = 0; j < COLS; j++) {
            picrossGrid[i][j] = false;
        }
    }
}

void freePicrossGrid() {
    if (picrossGrid != NULL) {
        for (int i = 0; i < ROWS; i++) {
            free(picrossGrid[i]);
        }
        free(picrossGrid);
    }
}

void handleMouseClick(int x, int y) {
    int col = x / CELL_SIZE;
    int row = y / CELL_SIZE;

    // Affichage des coordonnées de clics
    printf("Clic à la position (%d, %d)\n", x, y);
    printf("Correspond à la cellule (%d, %d)\n", row, col);

    // Vérifier si les indices sont dans les limites de la grille
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
        picrossGrid[row][col] = !picrossGrid[row][col];
    }
}

void render() {
    SDL_SetRenderDrawColor(gRenderer, 255, 255, 255, 255);
    SDL_RenderClear(gRenderer);

    // Dessin de la grille et des indices
    drawGrid();
    drawIndices();

    SDL_RenderPresent(gRenderer);
}

void drawGrid() {
    SDL_SetRenderDrawColor(gRenderer, 0, 0, 0, 255);
    for (int i = 0; i <= ROWS; ++i) {
        SDL_RenderDrawLine(gRenderer, 0, i * CELL_SIZE, SCREEN_WIDTH, i * CELL_SIZE);
    }
    for (int j = 0; j <= COLS; ++j) {
        SDL_RenderDrawLine(gRenderer, j * CELL_SIZE, 0, j * CELL_SIZE, SCREEN_HEIGHT);
    }
}

void drawIndices() {
       TTF_Font* font = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf", 16);
    if (!font) {
        printf("Erreur lors du chargement de la police : %s\n", TTF_GetError());
        return;
    }
    SDL_Color couleur = {255, 255, 255};

    // Dessiner les indices pour les lignes
    for (int i = 0; i < ROWS; ++i) {
        char indexStr[3];
        sprintf(indexStr, "%d", i + 1);

        SDL_Surface* surfaceTexte = TTF_RenderText_Solid(font, indexStr, couleur);
        SDL_Texture* textureTexte = SDL_CreateTextureFromSurface(gRenderer, surfaceTexte);

        SDL_Rect dstRect;
        dstRect.x = INDEX_OFFSET;
        dstRect.y = i * CELL_SIZE + (CELL_SIZE - surfaceTexte->h) / 2;
        dstRect.w = surfaceTexte->w;
        dstRect.h = surfaceTexte->h;

        SDL_RenderCopy(gRenderer, textureTexte, NULL, &dstRect);

        SDL_FreeSurface(surfaceTexte);
        SDL_DestroyTexture(textureTexte);
    }

    // Dessiner les indices pour les colonnes
    for (int j = 0; j < COLS; ++j) {
        char indexStr[3];
        sprintf(indexStr, "%d", j + 1);

        SDL_Surface* surfaceTexte = TTF_RenderText_Solid(font, indexStr, couleur);
        SDL_Texture* textureTexte = SDL_CreateTextureFromSurface(gRenderer, surfaceTexte);

        SDL_Rect dstRect;
        dstRect.x = j * CELL_SIZE + (CELL_SIZE - surfaceTexte->w) / 2;
        dstRect.y = INDEX_OFFSET;
        dstRect.w = surfaceTexte->w;
        dstRect.h = surfaceTexte->h;

        SDL_RenderCopy(gRenderer, textureTexte, NULL, &dstRect);

        SDL_FreeSurface(surfaceTexte);
        SDL_DestroyTexture(textureTexte);
    }

    TTF_CloseFont(font);
}

int main(int argc, char* args[]) {
    initializeSDL();
    initPicrossGrid();

    bool quit = false;
    SDL_Event e;

    while (!quit) {
        while (SDL_PollEvent(&e) != 0) {
            if (e.type == SDL_QUIT) {
                quit = true;
            }
            else if (e.type == SDL_MOUSEBUTTONDOWN) {
                int x, y;
                SDL_GetMouseState(&x, &y);
                handleMouseClick(x, y);
            }
        }
        render();
    }

    freePicrossGrid();
    closeSDL();

    return 0;
}
